  // === HIT-AND-RUN SUMOBOT (Edge Priority + Dual Range Logic) ===
  //
  // STRATEGY:
  // - "Hit and Run" style: detect → attack → retreat → reposition
  // - Highest priority = EDGE sensors (safety first)
  // - Medium priority = SIDE sensors (for flanking attacks)
  // - Low priority = CENTER long-range sensor (enemy far detection)
  // - Includes opening rush maneuver before active combat
  //
  // HARDWARE:
  // - 4x Sharp GP2Y0A41SK0F (4–30 cm): A0, A1, A3, A4
  // - 1x Sharp GP2Y0A21YK0F (10–80 cm): A2 (center)
  // - 3x QTR-1RC edge sensors: 11 (LEFT), 12 (BACK), 13 (RIGHT)
  // - 1x Start Button: pin 10 (active LOW)
  //  GM25 12V 980RPM
  // 14.8v 150c 850mAh
  // 41mm diameter silicone wheels
  // - Motor Driver: Cytron URC10 (PWM_DIR mode)
  //      Left  motor: PWM=5, DIR=4
  //      Right motor: PWM=6, DIR=7

  // === HIT-AND-RUN SUMOBOT (Non-Blocking Pro Version) ===
// Responsive finite-state logic with real-time sensor checks.

#include <CytronMotorDriver.h>

// === CONFIG ===
#define DEBUG false
#define dbg(x) if (DEBUG) Serial.println(x)

// === Pins ===
#define OPP_LEFT         A0
#define OPP_CENTER_LEFT  A1
#define OPP_CENTER       A2
#define OPP_CENTER_RIGHT A3
#define OPP_RIGHT        A4
#define EDGE_LEFT   11
#define EDGE_BACK   12
#define EDGE_RIGHT  13
#define START_BUTTON 10

CytronMD motorL(PWM_DIR, 5, 4);
CytronMD motorR(PWM_DIR, 6, 7);

// === Thresholds ===
const int SIDE_THRESHOLD   = 350;
const int CENTER_THRESHOLD = 500;
const int EDGE_TRIGGER     = LOW;

// === Speeds ===
const int SEARCH_SPEED = 40;
const int ATTACK_SPEED = 100;
const int FLANK_SPEED  = 90;
const int RETREAT_SPEED = -90;
const int RELOCATE_SPEED = 70;

// === Timings ===
const unsigned long ATTACK_MIN_MS = 400;
const unsigned long ATTACK_MAX_MS = 700;
const unsigned long RETREAT_MS = 250;
const unsigned long RELOCATE_MS = 350;
const unsigned long EDGE_BACKUP_MS = 180;
const unsigned long EDGE_TURN_MS = 300;
const unsigned long SPIN_FLIP_MS = 1000;

bool openingDone = false;

// === State Machine ===
enum State { SEARCH, ATTACK, RETREAT, RELOCATE, EDGE_AVOID };
State botState = SEARCH;
unsigned long stateStart = 0;
unsigned long stateDuration = 0;
bool flankFromLeft = false;

// === Motor Helpers ===
int speedPWM(int pct) {
  return map(constrain(pct, -100, 100), -100, 100, -255, 255);
}
void setMotors(int l, int r) {
  motorL.setSpeed(speedPWM(l));
  motorR.setSpeed(speedPWM(r));
}
void stopMotors() { setMotors(0, 0); }

// === Utility ===
bool timeUp() {
  return (millis() - stateStart >= stateDuration);
}

bool edgeDetected() {
  static unsigned long lastEdgeTime = 0;
  bool edgeNow = (digitalRead(EDGE_LEFT) == EDGE_TRIGGER ||
                  digitalRead(EDGE_RIGHT) == EDGE_TRIGGER ||
                  digitalRead(EDGE_BACK) == EDGE_TRIGGER);
  if (edgeNow) lastEdgeTime = millis();
  return (millis() - lastEdgeTime < 80); // only valid within 80ms
}

// === Start Routine ===
void waitForStartButton() {
  dbg("Waiting for start...");
  while (digitalRead(START_BUTTON) == HIGH);
  delay(4800);
  dbg("Start!");
}

// === SETUP ===
void setup() {
  if (DEBUG) Serial.begin(9600);
  randomSeed(analogRead(A5) ^ micros());
  pinMode(EDGE_LEFT, INPUT_PULLUP);
  pinMode(EDGE_RIGHT, INPUT_PULLUP);
  pinMode(EDGE_BACK, INPUT_PULLUP);
  pinMode(START_BUTTON, INPUT_PULLUP);
  waitForStartButton();
  stateStart = millis();
}

// === MAIN LOOP ===
void loop() {
  // 1️⃣ Emergency button
  if (digitalRead(START_BUTTON) == LOW) {
    stopMotors();
    dbg("Emergency stop");
    delay(3000);
    while (digitalRead(START_BUTTON) == LOW);
    return;
  }

  // 2️⃣ Edge priority — interrupts any state
  if (edgeDetected()) {
    botState = EDGE_AVOID;
    stateStart = millis();
    stateDuration = EDGE_BACKUP_MS + EDGE_TURN_MS;
  }

  // === Sensor reads ===
  int L = analogRead(OPP_LEFT);
  int CL = analogRead(OPP_CENTER_LEFT);
  int C = analogRead(OPP_CENTER);
  int CR = analogRead(OPP_CENTER_RIGHT);
  int R = analogRead(OPP_RIGHT);

  // === STATE MACHINE ===
  switch (botState) {

    // ================== SEARCH ==================
    // ================== SEARCH ==================
    case SEARCH: {
      static bool spinDir = false;
      static unsigned long lastFlip = 0;

  // Flip direction every 1.5 seconds
      if (millis() - lastFlip > SPIN_FLIP_MS) {
        spinDir = !spinDir;
        lastFlip = millis();
  }

  // Smooth forward-arc motion (not pure spin)
      if (spinDir)
        setMotors(SEARCH_SPEED, SEARCH_SPEED * 0.4);   // arc right
      else
        setMotors(SEARCH_SPEED * 0.4, SEARCH_SPEED);   // arc left

  // Small forward boost every few seconds to keep it mobile
      if (millis() % 6000 < 200) {
        setMotors(SEARCH_SPEED + 20, SEARCH_SPEED + 20);
  }

  // Opponent detection
      bool sideDetect = (L < SIDE_THRESHOLD || CL < SIDE_THRESHOLD ||
                        CR < SIDE_THRESHOLD || R < SIDE_THRESHOLD);
      if (sideDetect) {
        flankFromLeft = (L + CL) < (CR + R);
        botState = ATTACK;
        stateStart = millis();
        stateDuration = random(ATTACK_MIN_MS, ATTACK_MAX_MS);
        setMotors(flankFromLeft ? FLANK_SPEED : 60,
                  flankFromLeft ? 60 : FLANK_SPEED);
  }
      else if (C < CENTER_THRESHOLD) {
        botState = ATTACK;
        stateStart = millis();
        stateDuration = random(ATTACK_MIN_MS, ATTACK_MAX_MS);
        setMotors(ATTACK_SPEED, ATTACK_SPEED);
  }
  break;
}


    // ================== ATTACK ==================
    case ATTACK: {
      if (timeUp()) {
        botState = RETREAT;
        stateStart = millis();
        stateDuration = RETREAT_MS;
        setMotors(RETREAT_SPEED, RETREAT_SPEED);
      }
      break;
    }

    // ================== RETREAT ==================
    case RETREAT: {
      if (timeUp()) {
        botState = RELOCATE;
        stateStart = millis();
        stateDuration = RELOCATE_MS;
        bool dir = random(0, 2);
        setMotors(dir ? RELOCATE_SPEED : -RELOCATE_SPEED,
                  dir ? -RELOCATE_SPEED : RELOCATE_SPEED);
      }
      break;
    }

    // ================== RELOCATE ==================
    case RELOCATE: {
      if (timeUp()) {
        botState = SEARCH;
        stopMotors();
      }
      break;
    }

    // ================== EDGE AVOID ==================
    case EDGE_AVOID: {
      unsigned long elapsed = millis() - stateStart;
      if (elapsed < EDGE_BACKUP_MS) {
        setMotors(-80, -80);
      }
      else if (elapsed < stateDuration) {
        bool Ledge = (digitalRead(EDGE_LEFT) == EDGE_TRIGGER);
        bool Redge = (digitalRead(EDGE_RIGHT) == EDGE_TRIGGER);
        bool Bedge = (digitalRead(EDGE_BACK) == EDGE_TRIGGER);

        if (Bedge) setMotors(80, 80); // Move forward if back edge
        else if (Ledge) setMotors(RELOCATE_SPEED, -RELOCATE_SPEED); // Turn right
        else if (Redge) setMotors(-RELOCATE_SPEED, RELOCATE_SPEED); // Turn left
        else {
          int randTurn = random(0, 2);
          setMotors(randTurn ? RELOCATE_SPEED : -RELOCATE_SPEED,
                    randTurn ? -RELOCATE_SPEED : RELOCATE_SPEED);
  }
  stateDuration = EDGE_BACKUP_MS + random(250, 400); // Random recovery time
}
 else {
        botState = SEARCH;
        stopMotors();
      }
      break;
    }
  }
}
